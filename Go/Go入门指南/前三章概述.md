# 前三章概述

- Go语言提倡通过==接口==来针对面向对象编程，通过**goroutine**和**channel**来支持并发和并行编程
- 类型安全、内存安全，有指针，但不允许进行指针运算
- 对网络通信、并发和并行编程有极佳的支持
- 构建（编译和链接到机器代码）速度很快
- 快速编译
- ==**静态、强类型语言**==，所有的东西都是显式的，隐式的类型转换是不被允许的
- Go支持交叉编译，是第一门完全支持UTF-8的编程语言
- 领域：
  高性能分布式系统
  复杂时间处理

- 标准类库、规范统一、易于部署、可移植性强

- 编译器：都是以单通道的形式工作
  1. Go原生编译器gc：
     1. 编译器和链接器使用c语言编写并产生本地代码，不存在自我引导，使用一个有不同指令集的编译器来构建go程序，需要针对操作系统和处理器架构进行区别对待
     2. 使用非分代、无压缩和并行的方式进行编译，编译速度比gccgo更快，产生更好的本地代码。但是编译后的程序不能够使用gcc链接
  2. 非原生编译器gccgo，可以通过安装MinGW从而在Windows平台下使用gcc编译器
     1. 使用gcc作为后端，能够构建基于众多处理器架构的应用程序，编译速度相对gc较慢，但是产生的本地代码运行稍微快一点
     2. 能提供一些与c语言之间的互操作性

- 文件夹名称永远不应该包含空格
- src（源码文件）、pkg（包文件）、bin（可执行文件）
- Linux下运行`go build`之后的文件，需要利用./
- 配置环境变量可以用`go env -w`
- Go运行时（runtime）（runtime是每个Go包的最顶级包）
  - Go编译器产生的是本地可执行代码，这些代码仍旧运行在Go的runtime（类似Java的虚拟机）当中
  - 负责管理内存分配、垃圾回收、栈处理、gorotine、channel、切片、map、反射等等
  - 分配和回收内容都是消耗CPU资源的一种行为
  - Go的runtime嵌入到了每一个可执行文件当中(Go的可执行文件都比相应的源代码文件要)
  - Go不需要依赖任何其他文件，只需要一个单独的静态文件

- 调试器：gdb

- 1. 在合适的位置使用打印语句输出相关变量的值（ print / println 和 fmt.Print / fmt.Println / fmt.Printf ）。
  2.   在 fmt.Printf 中使用下面的说明符来打印有关变量的相关信息：
      %+v 打印包括字段在内的实例的完整信息 
      %#v 打印包括字段和限定类型名称在内的实例的完整信息 
      %T 打印某个类型的完整说明 。
  3. 使用 panic 语句（第 13.2 节）来获取栈跟踪信息（直到 panic 时所有被调用函数的列表）。
  4.  使用关键字 defer 来跟踪代码执行过程）。

- 构建程序之前自动调用源码格式化工具gofmt,并自动保存格式化后的源文件
  构建失败：`a declared and not used`
  执行顺利：`Program exited with code 0`

  `go build`:编译并安装自身包和依赖包
  `go install` :安装自身包和依赖包

- `gofmt(go fmt)`

  - `gofmt -w program.go`会格式化该源文件的代码然后将格式化后的代码覆盖原始内容（不加w只会打印格式化后的结果而不重写文件）

  - `gofmt -w *.go`会格式化并重写所有Go源文件
  - `gofmt map1`会格式化并重写map1目录及其子目录下的所有Go源文件
  - 还有很多细节

- `go doc ` 从 Go 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档。也可以作为一个提供在线文档浏览的web服务器

  - `go doc package` 获取包的文档注释，例如： go doc fmt 会显示使用 godoc 生成的 fmt 包的文档注释。
  - ` go doc package/subpackage` 获取子包的文档注释，例： go doc container/list 。 
  - `go doc package function` 获取某个函数在某个包中的文档注释，例如： `go doc fmt Printf `会显示有关 fmt.Printf() 的使用说明。
  - `godoc` 也可以用于生成非标准库的 Go 源码文件的文档注释。

- 其他工具
  - `go install`,`go fix`,`go test(轻量级的单元测试框架)`

- 根据 Go 开发团队和基本的算法测试，Go 语言与 C 语言的性能差距大概在 10%~20% 之间（该数据在2013/3.28之前产生）
- 通过cgo可以与c语言进行交互，调用代码（需要导包）（不做记录，仅了解（目前看来还是很有趣的））
- 可以与C++（Linux系统下使用）进行交互（仅做了解，也很有趣）
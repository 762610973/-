### 文件名、关键字、标识符

- 以`.go`为后缀名，文件名由多个部分组成，使用下划线`_`分割

- 有效的标识符必须以字符（任何UTF-8编码的字符或`_`）开头，数字开头不可以

- `_`：空白标识符，任何类型都可以赋值给它，但任何赋值给这个标识符的值都将被抛弃

- ==匿名变量==：没有名称的变量、类型或方法（可以增加代码灵活性）

- **关键字/保留字**(25，数量少是为了简化在编译过程中第一步中的代码解析)

  | break    | default     | func   | interface | select |
  | -------- | ----------- | ------ | --------- | ------ |
  | case     | defer       | go     | map       | struct |
  | chan     | else        | goto   | package   | switch |
  | const    | fallthrough | if     | range     | type   |
  | continue | for         | import | return    | var    |

  还有36个预定义标识符，其中包含了基本类型的名称和一些基本的内置函数

### Go程序的基本结构和要素

- 包是结构化代码的一种方式：每个程序都由包的概念组成
- 每个Go文件都属于且仅属于一个包，文件名和包名一般来说不相同
- 在源文件中非注释的第一行指明这个文件属于哪个包
- ` package main` 表示一个可独立执 行的程序，每个 Go 应用程序都包含一个名为 `main `的包。
- 编译包名不是为` main` 的源文件，如 `pack1` ，编译后产生的对象文件将会是` pack1.a` 而不是可执行程 序。所有包名都应该使用**小写字母**
- 在 Go 的安装文件里包含了一些可以直接使用的包，即**标准库**。==
- ==包的依赖关系决定了其构建顺序==

- 属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个 包。一段代码只会被编译一次

- Go 中的包模型采用了显式依赖关系的机制来达到快速编译的目的，编译器会从后缀名为 .o 的对象文件（需要且 只需要这个文件）中提取传递依赖类型的信息。

- 一个 Go 程序是通过 import 关键字将一组包链接在一起。

- 包的导入

  `import "fmt" `

  `import "os"`

  ---------

  ` import "fmt"; import "os"`

  --------------------------------

  ```go
   import (
   "fmt"
   "os"
   )
  (因式分解关键字，适用于const、var、type的声明或定义)
  ```

- 标识符首字母大写，此标识符的对象可以被导出

- 包也可以作为命名空间使用，帮助避免命名冲突（名称冲突）：两个包中的同名变量的区别在于他们的包名
- 通过使用包的别名来解决包名之间的名称冲突，或者说根据你的个人喜好对包名进行重新设置：`import fm "fmt"`
- main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（**如果有 init() 函数则会 先执行该函数**）。如果你的 main 包的源代码没有包含 main 函数，则会引发构建错误 `undefined: main.main` 。 main 函数既没有参数，也没有返回类型（与 C 家族中的其它语言恰好相反）。如果你不小心为 main 函数添加了 参数或者返回类型，将会引发构建错误
- 程序开始执行并完成初始化后，第一个调用（程序的入口点）的函数时`main.main()`
- 驼峰命名法
- 在 package 语句之前的块注释将被默认认为是这个包的文档说明，其中应该提供一些相 关信息并对整体功能做简要的介绍。

- 几乎所有全局作用域的类型、常量、变量、函数和被导出的对象都应该有一个合理的注释。如果这种注释出现在函数前面，例如函数 Abcd，则要以 "Abcd..." 作为开头。
- 使用 var 声明的变量的值会自动初 始化为该类型的零值。
- 基本类型：`int,float,bool,string`
  结构化的（复合）：`struct,array,slice,map,channel`==没有真正的值，使用nil作为默认值==
  描述类型的行为的：`interface`
- 函数也可以是一个确定的类型（以函数作为返回类型）
- `type`关键字定义自己的类型

- ![image-20220103180659309](https://picgo-for-typora.oss-cn-beijing.aliyuncs.com/image-20220103180659309.png)

- Go语言不存在隐式类型转换，大范围转换到小范围发生精度丢（截断），编译错误

- 类型 B 的值 = 类型 B(类型 A 的值)

- 具有相同底层类型的变量之间可以相互转换

  ```go
  var a iz = 4
  c := int(a)
  d := iz(c)
  ```

### 常量

- `const`定义常量，用于存储不会改变的数据
- 存储在常量中的数据类型只可以是布尔型、数字型（整数、浮点数和复数）和字符串型

- 定义格式：`const name type = vaule/常量或者常量表达式`

- Go中可以省略类型说明符，编译器可以根据变量的值来推断其类型

  显示类型定义：`const b string = "abc"`

  隐式类型定义：`const b = "abc"`

- 未定义类型的常量 会在必要时刻根据上下文来获得相关类型。
- 常量的值必须是能够在编译时就能够确定的，常量中的函数必须是内置函数
- 数字型的常量没有大小和符号，可以使用任何精度而不会导致溢出

- 反斜杠 `\` 可以在常量表达式中作为多行的连接符使用。

- 常量可以使用并行赋值的形式

  ```go
  const beef, two, c = "eat", 2, "veg"
  const Mon, Tue, Wed, Thu, Fri, Sat = 1, 2, 3, 4, 5, 6
  const (
  Monday, Tuesday, Wednesday = 1, 2, 3
  Thursday, Friday, Saturday = 4, 5, 6
  )
  ```

- 常量可以用作枚举，可以用在表达式中

  ```go
  const (
  	a = 1
  	b	//1
  	c	//1
  )
  const (
  	a1,b1 = 1,2
  	c1,d1	//套用上面的，分别为1,2
  )
  const (
  	a2 = "123"
  	b2 = len(a2)//只能使用内置函数，是3
  	c2			//套用上面的表达式，是3
  )
  const (
  	//iota是常量的计数器，从0开始，组中每定义一个常量自动递增1
  	//通过初始化规则与iota可以达到枚举的效果
  	//每遇到一个const关键字，iota会重置为0
  	//常量组中使用iota
  	a3 = 'A'	//a3是int32类型
  	b3			//套用上面的，是65
  	b33			//接着套用
  	c3 = iota	//是2,新增b33之后变为3，从0递增值3
  	d3			//是3，因为出现了iota，要递增
  )
  const (
  	a4 = iota //0
  	b4		//1
  	c4		//2
  )
  ```

- 可以使用某个类型作为枚举常量的类型

  ```go
  type Color int
  const(
  	red color = iota
  )
  ```

### 变量

```go
var a int
var b bool
var str string
//因式分解关键字的写法一般用于声明全局变量
//当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string
//为空字符串，指针为 nil。记住，所有的内存在 Go 中都是经过初始化的。
var (
	a int
    b bool
    str string
)
```

- ==所有的内存在 Go 中都是经过初始化的。==
- 变量可以编译期间就被赋值,也可以在运行时对变量进行赋值操作。
- Go的编译器可以在编译时根据变量的值推断其类型

```go
//主要用于声明包级别的全局变量
//编译时
var a int = 1
var a = 1
//运行时
var (
	HOME = os.Getenv("HOME")
	USER = os.Getenv("USER")
	GOROOT = os.Getenv("GOROOT")
)
//局部变量使用简短声明语法
a := 1
```

- 所有 的字都使用相关的内存地址来进行表示（以十六进制数表示）。

- 所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的 值
- 程序中所用到的内存在计算机中用==字==来表示
- 数组和结构这些符合类型也是值类型
- `&i`可以用来获取i的内存地址
- 值类型的变量的值存储在栈中。
- 更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。

- 一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。

- 引用类型：指针、slices、map、channel。被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。

- **值类型的特点**是：变量直接存储值，内存通常在栈中分配

  **引用类型的特点**是：变量存储的是一个地址，这个地址对应的空间里才是真正存储的值，内存通常在堆中分配

- 使用操作符 `:= `可 以高效地创建一个新的变量，称之为初始化声明。

- `a,b = b,a`

- 变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。这是一类非常特殊的函数，它不能够被人为调 用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。

  ==每一个源文件都可以包含一个或多个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。==

  ```go
  var test int
  func init（）{
      test = 1
      fmt.Println(test)
  }
  //1
  func main() {
      test += 2
      fmt.Println(test)
  }
  //3
  ```

  

### 基本类型和运算符

- 表达式是一种特定的类型的值

- 一元运算符只可以用于一个值的操作（作为后缀），而二元运算符则可以和两个值或者操作数结合（作为中缀）。

- Go 对于值之间的比较有非常严格的限制，只有两个类型相同的值才可以进行比较，如果值的类型是接口 ，它们也必须都实现了相同的接口。

- 在 Go 语言中，&& 和 || 是具有快捷性质的运算符，当运算符左边表达式的值已经能够决定整个表达式的值的时候 （&& 左边的值为 false，|| 左边的值为 true），运算符右边的表达式将不会被执行。利用这个性质，如果你有 多个条件判断，应当将计算过程较为复杂的表达式放在运算符的右侧以减少不必要的运算。

- bool类型命名用`is`或`Is`开头，提升代码的可读性

- bool：true/false（默认为false）

- `int` 和 `uint` 在 32 位操作系统上，它们均使用 32 位（4 个字节），在 64 位操作系统上，它们均使 用 64 位（8 个字节）。

  `uintptr` 的长度被设定为足够存放一个指针即可。

- 尽可能使用float64，因为main包中所有有关数学运算的函数都会要求接受这个类型
- `a := unit(64)`

- Go 中不允许不同类型之间的混合使用，但是对于常量的类型限制非常少，因此允许常量之间的混合使用，下面这个程 序很好地解释了这个现象（该程序无法通过编译）：
- `%n.mg`用于表示数字 n 并精确到小数点后 m 位

- 复数类型`complex64、complex128`
- 复数使用 `re+imI` 来表示

- 函数` real(c)` 和 `imag(c)` 可以分别获得相应的实数和虚数部分。

- - 位左移：`bitP << n`,右侧空白部分用0填，相当于成2的n次幂
  - 位右移：不在叙述
- 逻辑运算符：`b:= 10>5`//b 是true
- `rand`包实现了伪随机数的生成
- `Seed(value)`函数提供伪随机数的生成种子
- 类型别名:`type t int`
- 字符类型并不是Go语言的一个类型，字符只是整数的特殊用例
- `byte`类型是`uint8`的别名
- 字符同样称为 Unicode 代码点或者 runes，并在内存中使用 int来表示

- rune是Go中的一个类型，且是int32的别名
# 哈希表

### [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

> 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
>
> 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。
>

```go
package main
func isAnagram(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}//长度不相等，肯定不行
	maps := make(map[rune]int)
	for _,v := range s {
		maps[v] ++
	}//统计s中每个出现的次数
	mapt := make(map[rune]int)
	for _,v := range t {
		mapt[v] ++
	}//统计t中每个出现的次数
	for k,v := range maps {
		if mapt[k] != v {
			return false
		}//进行比对，有一个不相等就返回false
	}
	return true
}

//官方题解，更简单
func isAnagram(s, t string) bool {
    if len(s) != len(t) {
        return false
    }//判断长度
    cnt := map[rune]int{}
    for _, ch := range s {
        cnt[ch]++
    }//统计s
    for _, ch := range t {
        cnt[ch]--//遍历t，然后相减
        if cnt[ch] < 0 {//<0说明出现的次数不同，妙啊
            return false
        }
    }
    return true
}
//排序算法
func isAnagram(s, t string) bool {
    s1, s2 := []byte(s), []byte(t)
    sort.Slice(s1, func(i, j int) bool { return s1[i] < s1[j] })
    sort.Slice(s2, func(i, j int) bool { return s2[i] < s2[j] })
    return string(s1) == string(s2)
}
/*时间复杂度：O(nlog⁡n)，其中 n 为 s 的长度。排序的时间复杂度为 O(nlog⁡n))，比较两个字符串是否相等时间复杂度为 O(n)，因此总体时间复杂度为 O(nlog⁡n+n)=O(nlog⁡n)。
空间复杂度：O(log⁡n)。排序需要 O(log⁡n) 的空间复杂度。注意，在某些语言（比如 Java & JavaScript）中字符串是不可变的，因此我们需要额外的 O(n) 的空间来拷贝字符串。但是我们忽略这一复杂度分析，因为：
    这依赖于语言的细节；
    这取决于函数的设计方式，例如，可以将函数参数类型更改为 char[]。*/
```

#### [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)

> 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
>
> 如果可以，返回 true ；否则返回 false 。
>
> magazine 中的每个字符只能在 ransomNote 中使用一次。

```go
package main
//下面的解法为哈希表解法，也可以利用暴力解法，双层循环，如果存在，就删掉
func canConstruct(ransomNote string, magazine string) bool {
	mapRan := make(map[rune]int)//可以利用切片,切片性能高于map
    /*
    record := make([]int, 26)
    for _, v := range magazine {
        record[v-'a']++
    }
    */
	for _,v := range magazine {
		mapRan[v]++
	}//统计magazine中每个字符出现的次数
	for _,v := range ransomNote {
		mapRan[v]--//遍历ransomNote，无论是否出现，出现的次数都要-1
		if mapRan[v] < 0 {//如果-1后<0，那么肯定是不存在于magazine之中的
			return false
		}
	}
	return true
}

```

#### [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

> 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
>
> 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。
>

```go
package main
func findAnagrams(s,p string)(ans []int) {
	sLen,pLen := len(s),len(p)
	if sLen < pLen {
		return nil
	}//s长度小于p长度，肯定不行
	sCnt,pCnt := [26]int{},[26]int{}
	for i := 0;i < pLen; i++ {
		sCnt[s[i]-'a']++
		pCnt[p[i]-'a']++
	}
	//初始窗口相等
	if sCnt == pCnt {
		ans = append(ans,0)
	}
	for i := 0;i < sLen-pLen; i++ {
		sCnt[s[i]-'a']--//左边界--
		sCnt[s[i+pLen]-'a']++//右边界++
		//向右移动窗口
		if sCnt == pCnt {
			ans = append(ans,i+1)//这个是向右移动一次之后符合结果，因此i+1才是正确的weizhi
		}
	}
	return
}
//针对词频统计的题目，可以把两个词频表合成一个
//一个字符串往里加次数，另一个字符串往词频里面减次数，再加一个变量记录词频差异数，如果差异数为0，说明两个字符串互为异位词
func findAnagrams(s,p string) (ans []int) {
	sLen,pLen := len(s),len(p)
	if sLen < pLen {
		return nil
	}
	cnt := [26]int{}
	differ := 0
	//得到滑动窗口中每种字母的数量与字符串p中每种字母的数量差异
	for i := 0; i < pLen; i++ {
		cnt[s[i]-'a']++
		cnt[p[i]-'a']--//初始全为负的，然后看s中有几个，全加上去，因为是从s往cnt中加

	}
	for i := 0; i < 26; i++ {
		if cnt[i] != 0 {
			//遍历词频数组，统计差异数
			differ++
		}
	}
	if differ == 0 {
		ans = append(ans,0)
	}
	for i := 0; i < sLen-pLen; i++ {
		cnt[s[i]-'a']--//移除窗口左边的字符
		if cnt[s[i]-'a'] == 0 {
			differ--//如果移除这个字符之后，词频数变为0，差异数-1
		} else if cnt[s[i]-'a'] == -1 {
			differ ++//这个字符的词频变为-1，说明原来是0，differ+1，差异数+1
		}
		cnt[s[i+pLen]-'a']++
		if cnt[s[i+pLen]-'a'] == 1 {
			differ++
		}else if cnt[s[i+pLen]-'a'] == 0 {
			differ --
		}
		if differ == 0 {
			ans = append(ans,i+1)
		}//differ统计的是差异的字符类别，等于0说明不存在差异的字符，可以直接加入答案
	}
	return
}

```

#### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

> 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。
>
> 字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次
>

```go
package main
func groupAnagrams(strs []string) [][]string {
    mp := make(map[[26]int][]string,0)
    for _,str := range strs {
        cnt := [26]int{}
        for _,element := range str {
            cnt[element-'a']++
        }
        mp[cnt] = append(mp[cnt],str)//将相同cnt的放到一个string切片中
    }
    ans := make([][]string,0,len(mp))
    for _,v := range mp {
        ans = append(ans,v)//将value放入到新的切片中
    }
    return ans
}
/*
时间复杂度：O(n(k+∣Σ∣))，其中 n 是 strs 中的字符串的数量，kkk 是 strs 中的字符串的的最大长度，Σ 是字符集，在本题中字符集为所有小写字母，∣Σ∣=26。需要遍历 n 个字符串，对于每个字符串，需要 O(k) 的时间计算每个字母出现的次数，O(∣Σ∣) 的时间生成哈希表的键，以及 O(1) 的时间更新哈希表，因此总时间复杂度是 O(n(k+∣Σ∣))

空间复杂度：O(n(k+∣Σ∣))，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的最大长度，Σ 是字符集，在本题中字符集为所有小写字母，∣Σ∣=26。需要用哈希表存储全部字符串，而记录每个字符串中每个字母出现次数的数组需要的空间为 O(∣Σ∣)，在渐进意义下小于 O(n(k+∣Σ∣))，可以忽略不计。

*/

```

### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
>
> 你可以按任意顺序返回答案
>

```go
func twoSum(nums []int,target int) []int {
    m := make(map[int]int)
    for i := 0;i < len(nums); i++ {
        another := target - nums[i]
        if _,ok :=  m[another] {
            return []int{m[another],i}
        }
        m[nums[i]] = i
    }
    return nil
}
```

### [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

> 给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

```go
package main
//两种解法都是实现一个set，遍历nums1，将set填充，然后遍历nums2
func intersection(nums1 []int, nums2 []int) []int {
	m := make(map[int]int)
	for _,v := range nums1 {
		m[v] = 1
	}
	var res []int
	//利用count>0，实现重复值只拿一次放入返回结果中
	for _,v := range nums2 {
		if count,ok := m[v];ok && count > 0 {
			res = append(res,v)
			m[v]--
		}
	}
	return res
}
//优化之后的版本
func intersection(nums1 []int, nums2 []int) []int {
	mSet := make(map[int]int)
	//遍历nums1，不存在于set中，就加入，这样可以利用map实现一个set
	for _,v := range nums1 {
		if _,ok := mSet[v];!ok {
			mSet[v] = 1
		}
	}
	/*
	for _,v := range nums1 {
		mSet[v] = 1
	//这段代码的实现效果和上面的是一样的
	}*/
	ans := make([]int,0)
	for _,value := range nums2 {
		if _,ok := mSet[value];ok {
			ans = append(ans,value)
			delete(mSet,value)//当前数字添加入ans之后，从set中删除，这样nums2中重复的数字就不会加入其中了
		}
	}
	return ans
}

```

#### [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

> 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

```go
package main
/*func intersect(nums1 []int, nums2 []int) []int {
	ans := make([]int,0)
	m := make(map[int]int)
	//首先遍历较短的，节省空间
	if len(nums1) > len(nums2) {
        return intersect(nums2, nums1)
    }
	//map的k是元素，v是出现的次数
	for _,value := range nums1 {
		m[value]++
	}
	//遍历nums2，如果存在并且m[v]>0，就添加到ans当中，同时m[v]--
	//m[v]>0是因为要考虑较小值，遍历过程中，如果存在但是小于0，说明nums2中存在的这个数字多于nums1中的
	for _,v := range nums2 {
		if _,ok := m[v];ok && m[v] > 0 {
			ans = append(ans,v)
			m[v]--
		}
	}
	return ans
}*/
//思路是先排序,然后利用两个指针分别遍历两个切片，进行比较然后往后遍历
import "sort"
func intersect(nums1 []int, nums2 []int) []int {
	sort.Ints(nums1)
	sort.Ints(nums2)
	nums1Len := len(nums1)
	nums2Len := len(nums2)
	p1,p2 := 0,0
	ans := make([]int,0)
	for p1 < nums1Len && p2 < nums2Len {
		if nums1[p1] < nums2[p2] {
			p1++
		} else if nums1[p1] > nums2[p2] {
			p2++
		} else {
			ans = append(ans,nums1[p1])
			p1++
			p2++
		}
	}
	return ans
}
```

### [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

> 编写一个算法来判断一个数 n 是不是快乐数。
>
> 「快乐数」 定义为：
>
> > 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
> > 然后重复这个过程直到这个数变为 1，也可能是 <u>**无限循环**</u> 但始终变不到 1。
> > 如果这个过程 结果为 1，那么这个数就是快乐数。
>
> 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

```go
package main
func isHappy(n int) bool {
	m := make(map[int]bool)
	//当n不为1或者没有再次出现初始的n的时候，一直循环
	//因为有可能再次出现初始的n
	for n != 1 && !m[n] {
		n,m[n] = getSum(n),true//没出现就为true
	}
	return n == 1
}
//得到和
func getSum(n int) int {
	sum := 0
	for n > 0 {
		sum += (n % 10)*(n  % 10)
		n = n/10
	}
	return sum
}
//时间复杂度是O(logn)
//空间复杂度是O(logn)
//快慢指针法，想象成一个链表，检测是否有环
func isHappy(n int) bool {
	slow,fast := n,getSum(n)//这里fast不能和slow一样，否则下面的循环就不会进行了
	for fast!= 1 && slow != fast {
		slow = getSum(slow)
		fast = getSum(getSum(slow))
	}
	return fast == 1
}
func getSum(n int) int {
	sum := 0
	for n > 0 {
		sum += (n % 10)*(n  % 10)
		n = n/10
	}
	return sum
}
//速度慢，超出时间限制
//时间复杂度是O(logn)
//空间复杂度是O(1)

```

```c++
//猜测在一定的次数内能找到就是找不到就不是了
//发现只有一个循环：4→16→37→58→89→145→42→20→4
bool isHappy(int n) {
        int temp=0;
        for(int i=0;n!=1&&i<10;++i){ //找10次找到返回，没找到不是快乐数
            n=getnext(n);
        }
        return n==1? true : false;
}
int getnext(int n){ //下个数
        int next=0;
        while(n>0){
            next+=(n%10)*(n%10);
            n/=10;
        }
        return next;
}
```

### [四数相加](https://www.programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC)

> 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：0 <= i, j, k, l < n 
>
> `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 `

```go
package main
//遍历nums1和nums2，将所有情况的和以及出现的次数添加到map中，然后再两次遍历nums3和nums4
func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int {
	m := make(map[int]int)
	count := 0
	for  _,v1 := range nums1 {
		for _,v2 := range nums2 {
			m[v1+v2]++
		}
	}
	for _,v3 := range nums3 {
		for _,v4 := range nums4 {
			count += m[-v3-v4]
		}
	}
	return count
}
//时间复杂度是O(n^2)
//空间复杂度是O(n)
-2 -1 -1 0 0 1 2
```

### [三数之和](https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/)

> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
> 注意：答案中不可以包含重复的三元组。
>

```go
package main
import (
	"sort"
)
// 思路是排序后遍历数组，让l和r在当前索引的右边
func threeSum(nums []int) [][]int {
	result := make([][]int,0)
	length := len(nums)
	if nums == nil || length < 3 {
		return nil
	}
	sort.Ints(nums)//对数组进行排序
	for i := 0;i < length-2; i++ {//这里循环的次数-2,0到倒数第三个就行，最后两个就是left,right
		if nums[i] > 0 {
			break//当前数字大于0，则三数之和一定不能为0了
		}
		if i >= 1 && nums[i] == nums[i-1] {
			continue//去重，当前数字和前一个一样，需要跳过去
		}
		left := i+1//左指针在nums[i]的右边
		right := length-1//右指针在最有一个元素
		for left < right {
			sum := nums[i] + nums[left] + nums[right]
			if sum == 0 {
				result = append(result,[]int{nums[i],nums[left],nums[right]})
				for left < right && nums[left] == nums[left+1] {
					left++
				}//去重，此时和为0，但是不能确定有没有重复值例如，-1(nums[i]),-1(left),-1(这个数不去重，会影响结果),0,1,2(right)
				for left < right && nums[right] == nums[right-1] {
					right--//不去重的话，下一次 循环就会统计这个数了
				}//去重
				left++
				right--
			} else if sum < 0 {//小于0，左指针向右移动
				left++
			} else {
				right--//大于0，右指针向左移动
			}
		}
	}
	return result
}
```

### [四数之和](https://www.programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html)

> 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：
>
>     0 <= a, b, c, d < n
>     a、b、c 和 d 互不相同
>     nums[a] + nums[b] + nums[c] + nums[d] == target
>
> 你可以按 任意顺序 返回答案 。

```go
package main
//思路与三数之和如出一辙
import "sort"
func fourSum(nums []int, target int) [][]int {
	length := len(nums)
	if nums == nil || length < 4 {
		return nil
	}
	sort.Ints(nums)
	ans := make([][]int,0)
	for i := 0; i < length-3; i++ {
		if i >= 1 && nums[i] == nums[i-1] {
			continue
		}
		for j := i+1; j < length-2; j++ {
			if j >= i+2 && nums[j] == nums[j-1] {
				continue
			}
			left,right := j+1,length-1
			for left < right {
				sum := nums[i]+nums[j]+nums[left]+nums[right]
				if sum == target {
					ans = append(ans,[]int{nums[i],nums[j],nums[left],nums[right]})
					for left < right && nums[left] == nums[left+1] {
						left++
					}
					for left < right && nums[right] == nums[right-1] {
						right--
					}
					left++
					right--
				} else if sum < target {
					left++
				} else {
					right--
				}
			}
		}
	}
	return ans
}
```

